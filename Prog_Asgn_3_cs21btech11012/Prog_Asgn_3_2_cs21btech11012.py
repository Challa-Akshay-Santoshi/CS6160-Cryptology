# Execute using the command
# python3 Prog_Asgn_3_2_cs21btech11012.py

# Akshay Santoshi
# CS21BTECH11012

from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes

def expandKey(shortKey):    
    shortKeyval1=shortKey[0]
    shortKeyval2=shortKey[1]    
    
    ByteA=shortKeyval1.to_bytes(1,"big")
    ByteB=shortKeyval2.to_bytes(1,"big")
    ByteC=(shortKeyval1^shortKeyval2).to_bytes(1,"big")
    hexByte1=0x94
    Byte1=hexByte1.to_bytes(1,"big")
    hexByte2=0x5a
    Byte2=hexByte2.to_bytes(1,"big")
    hexByte3=0xe7
    Byte3=hexByte3.to_bytes(1,"big")
    
    longKey=bytearray(ByteA)    
    longKey.extend(Byte1)
    longKey.extend(ByteB)    
    longKey.extend(Byte2)
    
    for i in range(4,9):        
        hexByte=(longKey[i-1]+longKey[i-4])%257
        if (hexByte==256):
            hexByte=0
        Byte=hexByte.to_bytes(1,"big")              
        longKey.extend(Byte)
    longKey.extend(ByteC)
    longKey.extend(Byte3)
    for i in range(11,16):
        hexByte=(longKey[i-1]+longKey[i-4])%257
        if (hexByte==256):
            hexByte=0
        Byte=hexByte.to_bytes(1,"big")              
        longKey.extend(Byte)    
    
    return longKey

# This function is used for getting a byte sequence(short key) from the key_guess
def gen_short_key(key_guess, short_key_length):
    short_key = [0] * short_key_length

    for i in range(short_key_length - 1, -1, -1):
        short_key[i] = key_guess & 0xff
        key_guess >>= 8

    return bytes(short_key)

def aesEncrypt(message_bytes,cipher):
    encryptor = cipher.encryptor()
    ciphertext = encryptor.update(message_bytes) + encryptor.finalize()
    return ciphertext

# This function is used to try all the possible key_guesses
# to generate the middle cipher text by encrypting the
# given_plaintext
def brute_force_encrypt(given_plaintext, key_guess):
    short_key = gen_short_key(key_guess, 2)  
    long_key = expandKey(short_key)  
    iv = b'\0' * 16  
    cipher = Cipher(algorithms.AES(long_key), modes.CBC(iv))

    return aesEncrypt(given_plaintext, cipher)


def aesDecrypt(message_bytes,cipher):
    decryptor = cipher.decryptor()
    plaintext = decryptor.update(message_bytes) + decryptor.finalize()
    return plaintext

# This function is used to try all the possible key_guesses
# and compare with given ciphertexts to generate the middle
# cipher text by decrypting the given_ciphertext
def brute_force_decrypt(given_ciphertext, key_guess):  
    short_key = gen_short_key(key_guess, 2)  
    long_key = expandKey(short_key)  
    iv = b'\0' * 16  
    cipher = Cipher(algorithms.AES(long_key), modes.CBC(iv))

    return aesDecrypt(given_ciphertext, cipher)


def main():
    plaintexts_file = "2aesPlaintexts.txt"
    ciphertexts_file = "2aesCiphertexts.txt"
    print("Computing!! Please wait....")
    plaintexts = []
    ciphertexts = []

    with open(plaintexts_file, 'r') as file:
        for line in file:
            byte_array = list(line.strip().encode('utf-8'))  
            plaintexts.append(bytes(byte_array))  

    with open(ciphertexts_file, 'r') as file:
        for line in file:
            hex_str = line.strip()
            byte_array = [int(hex_str[i:i+2], 16) for i in range(0, len(hex_str), 2)]
            ciphertexts.append(bytes(byte_array))

    # We create a lookup-table which consists of possible key guesses 
    # for encryption. Then we try each key_guess to find a match 
    # by brute force where we want the middle ciphertext generated by 
    # encrypting a plaintext to be equal to the middle ciphertext 
    # generated by decrypting a ciphertext.

    lookup_table = {}
    for key_guess in range(1 << 16):
        middle_cipher = brute_force_encrypt(plaintexts[0], key_guess)
        lookup_table[middle_cipher] = key_guess

    key1, key2, key1_expanded, key2_expanded = None, None, None, None
    for key_guess in range(1 << 16):
        decrypted = brute_force_decrypt(ciphertexts[0], key_guess)
        if decrypted and decrypted in lookup_table:
            key1, key2 = lookup_table[decrypted], key_guess
            key1_short_key = gen_short_key(key1, 2)
            key1_expanded = expandKey(key1_short_key)
            print("16-bit key1: ", hex(key1))
            print("128-bit expanded key1: ", key1_expanded.hex())
            key2_short_key = gen_short_key(key2, 2)
            key2_expanded = expandKey(key2_short_key)
            print("16-bit key2: ", hex(key2))
            print("128-bit expanded key2: ", key2_expanded.hex())
            break

    if key1 is None or key2 is None:
        print("NO KEY PAIRS FOUND!!")
        return -1

    iv = b'\0' * 16 
    key1_cipher = Cipher(algorithms.AES(key1_expanded), modes.CBC(iv))
    key2_cipher = Cipher(algorithms.AES(key2_expanded), modes.CBC(iv))

    all_match = True
    for i in range(len(plaintexts)):
        middle_cipher = aesEncrypt(plaintexts[i], key1_cipher)
        final_cipher = aesEncrypt(middle_cipher, key2_cipher)

        if final_cipher != ciphertexts[i]:
            print(f"Mismatch found for plaintext index {i}!")
            all_match = False
            break

    if all_match:
        print("Verification successful: All plaintexts match their corresponding ciphertexts!!")
    else:
        print("Verification failed: Key pair does not encrypt all plaintexts correctly!!")
        return

    middle_cipher = brute_force_decrypt(ciphertexts[-1], key2)
    secret_plaintext = brute_force_decrypt(middle_cipher, key1) if middle_cipher else None

    if secret_plaintext:
        print("Secret plaintext:", secret_plaintext.decode("utf-8"))
    else:
        print("COULDN'T FIND THE DECRYPTION OF THE CIPHERTEXT!!")


if __name__ == "__main__":
    main()
